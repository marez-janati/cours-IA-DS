<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cours Interactif : Introduction à Prolog</title>
    <style>
        :root {
            --color-primary: #4a6782;
            --color-accent: #e67e22;
            --color-text: #333333;
            --color-bg: #fdfdfd;
            --color-light-gray: #f4f4f4;
            --color-border: #dddddd;
            --font-body: 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
            --font-code: 'Courier New', monospace;
            --box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 960px;
            margin: 20px auto;
            padding: 0 20px;
        }

        h1, h2, h3, h4 {
            color: var(--color-primary);
            font-weight: 600;
            line-height: 1.3;
        }

        h1 {
            font-size: 2.5em;
            text-align: center;
            border-bottom: 2px solid var(--color-accent);
            padding-bottom: 10px;
            margin-bottom: 30px;
        }

        h2 {
            font-size: 2em;
            border-bottom: 1px solid var(--color-light-gray);
            padding-bottom: 8px;
            margin-top: 40px;
        }

        h3 {
            font-size: 1.5em;
            color: var(--color-accent);
            margin-top: 30px;
        }
        
        h4 {
            font-size: 1.2em;
            font-style: italic;
        }

        a {
            color: var(--color-accent);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        code {
            font-family: var(--font-code);
            background-color: #e7e7e7;
            padding: 3px 5px;
            border-radius: 4px;
            font-size: 0.95em;
            color: #c7254e;
        }

        pre {
            background-color: var(--color-light-gray);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid var(--color-border);
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.9em;
            overflow-x: auto;
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }

        /* Callout Boxes */
        .box {
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 5px;
            border-left: 5px solid;
            background-color: var(--color-light-gray);
        }
        .box-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        .box.definition { border-color: #4285F4; }
        .box.definition .box-title { color: #4285F4; }
        .box.example { border-color: #34A853; }
        .box.example .box-title { color: #34A853; }
        .box.warning { border-color: #FBBC05; background-color: #fffbeb;}
        .box.warning .box-title { color: #FBBC05; }
        .box.exercise { border-color: #EA4335; }
        .box.exercise .box-title { color: #EA4335; }

        /* Interactive Details for Exercises */
        details {
            margin-top: 10px;
        }
        summary {
            cursor: pointer;
            font-weight: bold;
            color: var(--color-primary);
            padding: 5px;
            border-radius: 4px;
        }
        summary:hover {
            background-color: var(--color-light-gray);
        }
        .solution {
            padding: 10px 15px;
            margin-top: 5px;
            border: 1px dashed var(--color-border);
            border-radius: 4px;
            background-color: #f9f9f9;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: var(--box-shadow);
        }
        th, td {
            border: 1px solid var(--color-border);
            padding: 10px 12px;
            text-align: left;
        }
        th {
            background-color: var(--color-primary);
            color: white;
            font-weight: bold;
            text-align: center;
        }
        tr:nth-child(even) {
            background-color: var(--color-light-gray);
        }
        tr:hover {
            background-color: #e9ecef;
        }
        
        /* Math symbols */
        .logic {
            font-weight: bold;
            color: var(--color-accent);
        }
        
        /* Table of Contents */
        #toc {
            background: var(--color-light-gray);
            border: 1px solid var(--color-border);
            border-radius: 5px;
            padding: 15px 25px;
            margin-bottom: 40px;
        }
        #toc h3 {
            margin-top: 0;
            text-align: center;
            color: var(--color-primary);
        }
        #toc ul {
            list-style-type: none;
            padding: 0;
        }
        #toc ul li {
            margin-bottom: 8px;
        }
        #toc ul ul {
            padding-left: 20px;
            margin-top: 5px;
        }
        
        /* Specific Prolog Syntax Highlighting imitation */
        .prolog-var { color: #9f6e08; font-weight: bold; }
        .prolog-atom { color: #2c3e50; }
        .prolog-comment { color: #7f8c8d; font-style: italic; }

        /* Mermaid Container */
        .mermaid-viz {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            background: white;
            border: 1px solid #eee;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Cours Interactif : Introduction à Prolog</h1>

        <nav id="toc">
            <h3>Table des Matières</h3>
            <ul>
                <li><a href="#part1">Partie 1 : Introduction et Concepts de Base</a>
                    <ul>
                        <li><a href="#section1-1">1.1. Programmation Logique vs Impérative</a></li>
                        <li><a href="#section1-2">1.2. Les Clauses de Horn</a></li>
                    </ul>
                </li>
                <li><a href="#part2">Partie 2 : Syntaxe et Constituants</a>
                    <ul>
                        <li><a href="#section2-1">2.1. Faits, Règles et Questions</a></li>
                        <li><a href="#section2-2">2.2. Syntaxe Spécifique Prolog</a></li>
                    </ul>
                </li>
                <li><a href="#part3">Partie 3 : Mécanisme de Résolution</a>
                    <ul>
                        <li><a href="#section3-1">3.1. L'Algorithme de Résolution</a></li>
                        <li><a href="#section3-2">3.2. Stratégies et Risques (Boucles Infinies)</a></li>
                    </ul>
                </li>
                 <li><a href="#part4">Partie 4 : Utilisation de SWI-Prolog</a></li>
                <li><a href="#part5">Partie 5 : Exercices d'Application Corrigés</a>
                    <ul>
                        <li><a href="#ex1">Exercice 1 : Ancêtre (Ordre des solutions)</a></li>
                        <li><a href="#ex2">Exercice 2 : Terminaison et Récursivité</a></li>
                        <li><a href="#ex3">Exercice 3 : Arbres de Recherche</a></li>
                    </ul>
                </li>
            </ul>
        </nav>

        <h2 id="part1">Partie 1 : Introduction et Concepts de Base</h2>

        <h3 id="section1-1">1.1. Programmation Logique vs Impérative</h3>

        <p>Prolog (PROgrammation en LOGique) est un langage dérivé du calcul des prédicats, créé en 1972 par Alain Colmerauer et Robert Kowalsky. C'est un langage déclaratif.</p>

        <div class="box definition">
            <div class="box-title">Langage Déclaratif</div>
            On déclare le <strong>QUOI</strong> (de quoi est fait le problème), plutôt que le <strong>COMMENT</strong> (comment le résoudre).
        </div>

        <!-- VISUALISATION: Declarative vs Imperative -->
        <div id="graph-paradigms" class="mermaid-viz"></div>

        <table>
            <thead>
                <tr>
                    <th>Programmation Logique (ex: Prolog)</th>
                    <th>Programmation Impérative (ex: C, Java)</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>Formule</td><td>Procédure</td></tr>
                <tr><td>Ensemble (conjonction) de formules</td><td>Programme</td></tr>
                <tr><td>Question</td><td>Appel de procédure</td></tr>
                <tr><td>Preuve</td><td>Exécution</td></tr>
                <tr><td>Substitution (unification)</td><td>Passage de paramètres</td></tr>
            </tbody>
        </table>

        <h3 id="section1-2">1.2. Les Clauses de Horn</h3>
        <p>Pour des raisons de performance de calcul, Prolog restreint les formules utilisables aux <strong>clauses de Horn</strong>.</p>

        <div class="box definition">
            <div class="box-title">Clause de Horn</div>
            Une clause de Horn est une disjonction de littéraux dont <strong>au plus un seul est positif</strong>.<br>
            Si elle a exactement un littéral positif, c'est une <strong>clause définie</strong>.
        </div>

        <p>Structure d'une clause définie : <code>φ1 ∧ φ2 ∧ ... ∧ φn → ψ</code></p>
        
        <!-- VISUALISATION: Horn Clause Structure -->
        <div id="graph-horn" class="mermaid-viz"></div>

        <ul>
            <li><strong>ψ</strong> est la <em>tête</em> de la clause.</li>
            <li><strong>φ1 ∧ ... ∧ φn</strong> est le <em>corps</em> de la clause.</li>
        </ul>

        <h4>Les trois types de clauses de Horn :</h4>
        <ul>
            <li><strong>Clause positive (Faits) :</strong> Pas de littéral négatif. <em>Exemple : p(a, b).</em></li>
            <li><strong>Clause stricte (Règles) :</strong> Un littéral positif et au moins un négatif.
                <br><code>p1 ∨ ¬n1 ∨ ... ∨ ¬nm</code> ≡ <code>(n1 ∧ ... ∧ nm) ⇒ p1</code>
            </li>
            <li><strong>Clause négative (Buts) :</strong> Pas de littéral positif.
                <br><code>¬n1 ∨ ... ∨ ¬nk</code>.
            </li>
        </ul>

        <h2 id="part2">Partie 2 : Syntaxe et Constituants</h2>

        <h3 id="section2-1">2.1. Faits, Règles et Questions</h3>
        <p>Un programme Prolog est constitué de trois éléments principaux :</p>
        
        <!-- VISUALISATION: Program Constituents -->
        <div id="graph-constituents" class="mermaid-viz"></div>

        <div class="box example">
            <div class="box-title">1. Les Faits</div>
            Ils affirment qu'une relation a lieu entre des objets.
            <br><em>Exemple :</em> <code>pere(ali, mohamed).</code> affirme que Ali est le père de Mohamed.
        </div>

        <div class="box example">
            <div class="box-title">2. Les Règles</div>
            Elles permettent de déduire de nouveaux faits à partir d'hypothèses.
            <br>Format : <code>A :- B1, B2, ..., Bn.</code> (A est vrai SI B1 et B2... sont vrais).
            <br><em>Exemple :</em> <code>fils(X, Y) :- pere(Y, X), masculin(X).</code>
        </div>

        <div class="box example">
            <div class="box-title">3. Les Questions (Buts)</div>
            On demande au système si une relation est vraie. L'interpréteur répond <strong>Yes</strong> (avec les valeurs des variables si nécessaire) ou <strong>No</strong>.
        </div>

        <h3 id="section2-2">2.2. Syntaxe Spécifique Prolog</h3>
        <p>Voici les conventions importantes de SWI-Prolog :</p>
        <table>
            <thead>
                <tr>
                    <th>Élément</th>
                    <th>Règle</th>
                    <th>Exemple</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Variables</strong></td>
                    <td>Commencent par une <strong>Majuscule</strong> ou <code>_</code></td>
                    <td><code>X</code>, <code>Resultat</code>, <code>_valeur</code></td>
                </tr>
                <tr>
                    <td><strong>Atomes (Constantes, Prédicats)</strong></td>
                    <td>Commencent par une <strong>minuscule</strong></td>
                    <td><code>ali</code>, <code>pere</code>, <code>x</code></td>
                </tr>
                <tr>
                    <td><strong>Fin d'instruction</strong></td>
                    <td>Point obligatoire</td>
                    <td><code>fait(a).</code></td>
                </tr>
                <tr>
                    <td><strong>Opérateurs Logiques</strong></td>
                    <td>ET = <code>,</code> | OU = <code>;</code> | SI = <code>:-</code></td>
                    <td><code>a :- b, c.</code></td>
                </tr>
            </tbody>
        </table>

        <h2 id="part3">Partie 3 : Mécanisme de Résolution</h2>

        <h3 id="section3-1">3.1. L'Algorithme de Résolution</h3>
        <p>Pour répondre à une question, Prolog construit un <strong>arbre de recherche SLD</strong> (Sélection Linéaire Définie).</p>
        <ul>
            <li>Il cherche à unifier le but avec la tête d'une clause.</li>
            <li>Il utilise l'algorithme d'<strong>unification</strong> de Robinson (trouver le substitut le plus général pour rendre deux termes identiques).</li>
        </ul>

        <div class="box definition">
            <div class="box-title">Stratégie de Prolog</div>
            <ol>
                <li><strong>Choix du littéral :</strong> Prolog choisit toujours le littéral le plus à <strong>gauche</strong> dans la liste des buts.</li>
                <li><strong>Choix de la clause :</strong> Prolog parcourt les règles du programme de <strong>haut en bas</strong> (ordre d'écriture).</li>
                <li><strong>Parcours :</strong> Prolog utilise un parcours en <strong>profondeur d'abord</strong> (Depth-First) avec retour en arrière (backtracking) en cas d'échec.</li>
            </ol>
        </div>

        <!-- VISUALISATION: Resolution Strategy -->
        <div id="graph-resolution" class="mermaid-viz"></div>

        <h3 id="section3-2">3.2. Stratégies et Risques (Boucles Infinies)</h3>
        <p>La stratégie en profondeur d'abord de Prolog n'est pas complète : elle peut tomber dans des branches infinies.</p>

        <div class="box warning">
            <div class="box-title">⚠️ Attention : L'ordre compte !</div>
            L'ordre des règles dans le programme et l'ordre des littéraux dans le corps d'une règle sont cruciaux. Un mauvais ordre peut entraîner une <strong>boucle infinie</strong>.
        </div>

        <div class="box example">
            <div class="box-title">Exemple de boucle</div>
            <pre><code>d.
a :- b.
b :- c.
c :- a.  /* Boucle ici si on demande 'a' */
c :- d.</code></pre>
            <p>Prolog va tenter <code>a -> b -> c -> a -> ...</code> indéfiniment. Si on inverse les deux dernières lignes, Prolog trouvera la solution <code>d</code> avant de boucler.</p>
            
            <!-- VISUALISATION: Infinite Loop -->
            <div id="graph-loop" class="mermaid-viz"></div>
        </div>

        <h2 id="part4">Partie 4 : Utilisation de SWI-Prolog</h2>
        <p>Quelques commandes utiles pour l'interpréteur :</p>
        <ul>
            <li>Charger un fichier : <code>consult('mon_fichier.pl').</code> ou <code>['mon_fichier.pl'].</code></li>
            <li>Écrire dans le terminal : <code>[user].</code> (Faire CTRL+D pour finir).</li>
            <li>Lister les clauses : <code>listing(nom_predicat).</code></li>
            <li>Quitter : <code>halt.</code></li>
            <li>Activer le mode trace (debug) : <code>trace.</code> (Désactiver avec <code>notrace.</code>).</li>
        </ul>

        <h2 id="part5">Partie 5 : Exercices d'Application Corrigés</h2>

        <h3 id="ex1">Exercice 1 : Ancêtre (Ordre des solutions)</h3>
        <p>Soit le programme suivant :</p>
        <pre><code>parent(fatma, ali). 
parent(ali, mohamed). 
parent(mohamed, jamel). 
parent(jamel, yassine). 

ancetre(X, Y) :- parent(X,Y).
ancetre(X, Z) :- parent(X,W), ancetre(W,Z).</code></pre>
        
        <div class="box exercise">
            <div class="box-title">Question 1</div>
            Quelles sont les solutions retournées par Prolog pour la question <code>ancetre(fatma, X).</code> et dans quel ordre ?
            <details>
                <summary>Voir la solution</summary>
                <div class="solution">
                    <p>Prolog explore d'abord la première règle (parent direct), puis la seconde (récursive).</p>
                    <!-- VISUALISATION: Ancestor Standard Order -->
                    <div id="graph-ancestor-1" class="mermaid-viz"></div>
                    <ol>
                        <li>X = ali (via la règle 1)</li>
                        <li>X = mohamed (via la règle 2 -> parent(fatma, ali), ancetre(ali, X))</li>
                        <li>X = jamel</li>
                        <li>X = yassine</li>
                    </ol>
                </div>
            </details>
        </div>

        <div class="box exercise">
            <div class="box-title">Question 2</div>
            Si on permute l'ordre des deux règles définissant <code>ancetre</code>, quel sera le nouvel ordre des solutions ?
            <details>
                <summary>Voir la solution</summary>
                <div class="solution">
                    <p>Prolog explorera d'abord la branche récursive (le plus profond) avant le fait direct.</p>
                    <!-- VISUALISATION: Ancestor Permuted Order -->
                    <div id="graph-ancestor-2" class="mermaid-viz"></div>
                    <ol>
                        <li>X = yassine</li>
                        <li>X = jamel</li>
                        <li>X = mohamed</li>
                        <li>X = ali</li>
                    </ol>
                    <strong>Conclusion :</strong> L'ordre des règles détermine l'ordre des solutions.
                </div>
            </details>
        </div>

        <h3 id="ex2">Exercice 2 : Terminaison et Récursivité</h3>
        <p>On veut définir une relation symétrique "marié".</p>
        <pre><code>married(X, Y) :- married(Y, X).</code></pre>
        <div class="box warning">
            <div class="box-title">Analyse</div>
            Si on pose la question <code>married(ali, fatma)</code>, Prolog va appeler <code>married(fatma, ali)</code>, qui va appeler <code>married(ali, fatma)</code>...
            <br>C'est une <strong>récursivité gauche</strong> qui entraîne une boucle infinie immédiate.
            <!-- VISUALISATION: Left Recursion Loop -->
            <div id="graph-recursion-loop" class="mermaid-viz"></div>
        </div>
        
        <div class="box example">
            <div class="box-title">La bonne pratique</div>
            Il faut distinguer la relation de base de la propriété symétrique en créant un nouveau prédicat :
            <pre><code>are_married(X, Y) :- married(X, Y).
are_married(X, Y) :- married(Y, X).</code></pre>
        </div>

        <h3 id="ex3">Exercice 3 : Arbres de Recherche</h3>
        <p>Soit le programme P :</p>
        <pre><code>b(1).
b(2).
c(3).
c(4).
d(4).
a(X) :- b(X). 
a(X) :- c(X), d(X).</code></pre>

        <div class="box exercise">
            <div class="box-title">Question</div>
            Donnez les solutions pour le but <code>a(X)</code>.
            <details>
                <summary>Voir la solution</summary>
                <div class="solution">
                    <p>Prolog construit l'arbre suivant :</p>
                    <!-- VISUALISATION: SLD Tree for a(X) -->
                    <div id="graph-sld-tree" class="mermaid-viz"></div>
                    <ol>
                        <li>Il tente la première règle : <code>a(X) :- b(X).</code>
                            <ul>
                                <li>Unification avec <code>b(1)</code> -> <strong>Solution X = 1</strong></li>
                                <li>Unification avec <code>b(2)</code> -> <strong>Solution X = 2</strong></li>
                            </ul>
                        </li>
                        <li>Il tente la seconde règle : <code>a(X) :- c(X), d(X).</code>
                            <ul>
                                <li>Unification avec <code>c(3)</code>. Nouveau but : <code>d(3)</code>. Échec (pas de fait d(3)).</li>
                                <li>Unification avec <code>c(4)</code>. Nouveau but : <code>d(4)</code>.
                                    <ul>
                                        <li>Unification avec <code>d(4)</code> -> Succès. <strong>Solution X = 4</strong>.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    Solutions finales : 1, 2, 4.
                </div>
            </details>
        </div>

    </div>

    <!-- MERMAID RENDERER SCRIPT -->
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

        // 1. Initialize configuration
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });

        /**
         * Renders a Mermaid graph into a specific HTML container.
         * @param {string} elementId - The ID of the div where you want the graph.
         * @param {string} graphCode - The raw Mermaid text code.
         */
        window.renderGraph = async function(elementId, graphCode) {
            try {
                const container = document.getElementById(elementId);
                if (!container) {
                    console.error(`Container with ID "${elementId}" not found.`);
                    return;
                }

                // Clear previous content
                container.innerHTML = '';

                // Generate a unique ID for the SVG to prevent conflicts
                const id = `graph-svg-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

                // Render the graph (returns an object with the SVG string)
                const { svg } = await mermaid.render(id, graphCode);
                
                // Inject the SVG into your container
                container.innerHTML = svg;
                
            } catch (error) {
                console.error('Mermaid syntax error for ' + elementId + ':', error);
                document.getElementById(elementId).innerHTML = 
                    `<p style="color:red; font-weight:bold;">Graph Syntax Error (Check Console)</p>`;
            }
        };

        // 2. Define Graphs and Render
        
        // Graph 1: Paradigms
        const graphParadigms = `
        graph TD
            subgraph "Programmation Impérative"
                I1[Instruction 1] --> I2[Instruction 2]
                I2 --> I3[Instruction 3]
                I3 --> I_End((Résultat))
            end
            subgraph "Programmation Logique"
                KB[("Base de Connaissances<br>(Faits + Règles)")] 
                Q[/? Question ?/]
                KB --> Engine[[Moteur d'Inférence]]
                Q --> Engine
                Engine --> Ans([Réponse: Vrai/Faux/Valeurs])
            end
            style Engine fill:#e1f5fe,stroke:#01579b
        `;
        window.renderGraph('graph-paradigms', graphParadigms);

        // Graph 2: Horn Clause
        const graphHorn = `
        graph LR
            Body["Corps<br>(Conditions)"] -->|Implique| Head["Tête<br>(Conclusion)"]
            subgraph "Exemple: fils(X,Y)"
                B1["pere(Y, X)"] & B2["masculin(X)"] --> H1["fils(X, Y)"]
            end
            style Head fill:#d4edda,stroke:#28a745
            style Body fill:#fff3cd,stroke:#ffc107
        `;
        window.renderGraph('graph-horn', graphHorn);

        // Graph 3: Constituents
        const graphConstituents = `
        graph TD
            Prog[Programme Prolog]
            Prog --> Facts[Faits]
            Prog --> Rules[Règles]
            Prog --> Queries[Questions / Buts]
            
            Facts --> F_Ex["pere(ali, mohamed)."]
            Rules --> R_Ex["fils(X,Y) :- pere(Y,X)."]
            Queries --> Q_Ex["?- fils(mohamed, ali)."]
            
            style Facts fill:#e2e3e5
            style Rules fill:#e2e3e5
            style Queries fill:#e2e3e5
        `;
        window.renderGraph('graph-constituents', graphConstituents);

        // Graph 4: Resolution Strategy
        const graphResolution = `
        graph TD
            Start((Début)) --> Goal[Liste de Buts]
            Goal --> Select{Sélectionner<br>But de Gauche}
            Select --> FindRule{Chercher Règle<br>dans KB}
            
            FindRule -->|Trouvée| Unify[Unification]
            FindRule -->|Non Trouvée| Fail[Échec / Backtrack]
            
            Unify -->|Succès| NewGoal[Remplacer But par<br>Corps de la Règle]
            Unify -->|Échec| Fail
            
            NewGoal --> IsEmpty{Liste Vide?}
            IsEmpty -->|Oui| Success((Succès))
            IsEmpty -->|Non| Select
            
            Fail --> Backtrack[Remonter au<br>dernier choix]
            Backtrack --> FindRule
            
            style Success fill:#d4edda,stroke:#28a745
            style Fail fill:#f8d7da,stroke:#dc3545
        `;
        window.renderGraph('graph-resolution', graphResolution);

        // Graph 5: Infinite Loop
        const graphLoop = `
        graph TD
            Q[? a] -->|Règle: a :- b| B[? b]
            B -->|Règle: b :- c| C[? c]
            C -->|Règle: c :- a| A_Recur[? a]
            A_Recur -.->|Boucle Infinie| Q
            style A_Recur fill:#f8d7da,stroke:#dc3545,stroke-width:2px
        `;
        window.renderGraph('graph-loop', graphLoop);

        // Graph 6: Ancestor Standard Order (Detailed)
        const graphAncestor1 = `
        graph TD
            %% Styles
            classDef solution fill:#d4edda,stroke:#28a745,stroke-width:2px;
            classDef goal fill:#e2e3e5,stroke:#6c757d,stroke-width:2px;

            Root[("ancetre(fatma, Reponse)")]:::goal

            %% BRANCHE 1
            Root -- "Règle 1: parent(fatma, Reponse)" --> Goal1["parent(fatma, Reponse)"]:::goal
            Goal1 -- "Unif: parent(fatma, ali)" --> Sol1("SUCCÈS #1<br>Reponse = ali"):::solution

            %% BRANCHE 2
            Root -- "Backtrack Règle 2" --> Goal2["parent(fatma, W), ancetre(W, Reponse)"]:::goal
            Goal2 -- "W=ali" --> Goal2_Step2["ancetre(ali, Reponse)"]:::goal

                %% SOUS-BRANCHE 2.1
                Goal2_Step2 -- "Règle 1: parent(ali, Reponse)" --> Goal2_1["parent(ali, Reponse)"]:::goal
                Goal2_1 -- "Unif: parent(ali, mohamed)" --> Sol2("SUCCÈS #2<br>Reponse = mohamed"):::solution

                %% SOUS-BRANCHE 2.2
                Goal2_Step2 -- "Backtrack Règle 2" --> Goal2_2["parent(ali, W2), ancetre(W2, Reponse)"]:::goal
                Goal2_2 -- "W2=mohamed" --> Goal2_2_Step2["ancetre(mohamed, Reponse)"]:::goal

                    %% SOUS-SOUS-BRANCHE 2.2.1
                    Goal2_2_Step2 -- "Règle 1" --> Sol3("SUCCÈS #3<br>Reponse = jamel"):::solution

                    %% SOUS-SOUS-BRANCHE 2.2.2 (Simplifiée pour l'affichage)
                    Goal2_2_Step2 -- "Règle 2 (via Jamel)" --> Sol4("SUCCÈS #4<br>Reponse = yassine"):::solution
        `;
        window.renderGraph('graph-ancestor-1', graphAncestor1);

        // Graph 7: Ancestor Permuted Order
        const graphAncestor2 = `
        graph TD
            classDef solution fill:#d4edda,stroke:#28a745,stroke-width:2px;
            classDef goal fill:#e2e3e5,stroke:#6c757d,stroke-width:2px;
            classDef fail fill:#f8d7da,stroke:#dc3545;

            Root[("ancetre(fatma, Reponse)")]:::goal

            %% Deep Dive First
            Root -- "Règle 1 (Récursive)" --> Lvl1["ancetre(ali, Reponse)"]:::goal
            Lvl1 -- "Règle 1 (Récursive)" --> Lvl2["ancetre(mohamed, Reponse)"]:::goal
            Lvl2 -- "Règle 1 (Récursive)" --> Lvl3["ancetre(jamel, Reponse)"]:::goal
            Lvl3 -- "Règle 1 (Récursive)" --> Lvl4["ancetre(yassine, Reponse)"]:::goal
            
            Lvl4 -- "Règle 1 (Pas d'enfant)" --> Fail1((Échec)):::fail
            Lvl4 -- "Backtrack Règle 2 (Base)" --> Fail2((Échec)):::fail

            %% Solving on the way up
            Lvl3 -- "Backtrack Règle 2 (Base)" --> Sol1("SUCCÈS #1<br>yassine"):::solution
            Lvl2 -- "Backtrack Règle 2 (Base)" --> Sol2("SUCCÈS #2<br>jamel"):::solution
            Lvl1 -- "Backtrack Règle 2 (Base)" --> Sol3("SUCCÈS #3<br>mohamed"):::solution
            Root -- "Backtrack Règle 2 (Base)" --> Sol4("SUCCÈS #4<br>ali"):::solution
        `;
        window.renderGraph('graph-ancestor-2', graphAncestor2);

        // Graph 8: Recursion Loop
        const graphRecLoop = `
        graph LR
            Q["married(ali, fatma)"] -->|Appelle| Q2["married(fatma, ali)"]
            Q2 -->|Appelle| Q3["married(ali, fatma)"]
            Q3 -.->|Boucle| Q2
            style Q3 fill:#f8d7da,stroke:#dc3545
        `;
        window.renderGraph('graph-recursion-loop', graphRecLoop);

        // Graph 9: SLD Tree for a(X)
        const graphSLD = `
        graph TD
            classDef solution fill:#d4edda,stroke:#28a745;
            classDef fail fill:#f8d7da,stroke:#dc3545;
            
            Root["a(X)"] 
            
            Root -- "R1: a(X) :- b(X)" --> B["b(X)"]
            B -- "Unif: b(1)" --> S1("X = 1"):::solution
            B -- "Unif: b(2)" --> S2("X = 2"):::solution
            
            Root -- "R2: a(X) :- c(X), d(X)" --> C["c(X), d(X)"]
            
            C -- "Unif: c(3)" --> D1["d(3)"]
            D1 -- "Pas de fait d(3)" --> F1((Échec)):::fail
            
            C -- "Unif: c(4)" --> D2["d(4)"]
            D2 -- "Unif: d(4)" --> S3("X = 4"):::solution
        `;
        window.renderGraph('graph-sld-tree', graphSLD);

    </script>
</body>
</html>
